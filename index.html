<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mindscribe</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Style for scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-thumb {
            background-color: #4f46e5;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-track {
            background-color: #2d3748;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 transition-colors duration-300">

    <!-- Main Container for the entire application -->
    <!-- Initial content is a simple loading message to prevent a blank screen -->
    <div id="app" class="min-h-screen flex items-center justify-center">
        <div class="text-center">
            <h2 class="text-2xl font-semibold animate-pulse">Loading Mindscribe...</h2>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, orderBy } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-firestore.js";

        // --- Firebase Configuration ---
        // Using the user-provided configuration and merging in the required Canvas variables
        const firebaseConfig = {
            apiKey: "AIzaSyB7F1uRRiGdw489c_18aJeodbxrzsdFb5c",
            authDomain: "exonova-cd89c.firebaseapp.com",
            databaseURL: "https://exonova-cd89c-default-rtdb.firebaseio.com",
            projectId: "exonova-cd89c",
            storageBucket: "exonova-cd89c.firebasestorage.app",
            messagingSenderId: "465326262278",
            appId: "1:465326262278:web:1b7f8f62e1f46c5ca7db87",
            measurementId: "G-GGG45V0PEF"
        };
        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- Application State and Initialization ---
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // Global state object
        const state = {
            user: null,
            userId: null,
            notebooks: [],
            notes: [],
            selectedNotebookId: null,
            selectedNoteId: null,
            message: ''
        };

        // DOM elements
        const appContainer = document.getElementById('app');
        let noteUnsubscribe = null;

        // Helper function to update the message display
        const showMessage = (message, isError = false) => {
            state.message = message;
            const messageEl = document.getElementById('message-box');
            if (messageEl) {
                messageEl.textContent = message;
                messageEl.className = `p-3 rounded-xl shadow-lg mt-4 ${isError ? 'bg-red-500 text-white' : 'bg-indigo-600 text-white'}`;
                messageEl.classList.remove('hidden');
                setTimeout(() => {
                    messageEl.classList.add('hidden');
                }, 5000);
            }
        };

        // --- User Interface Rendering Functions ---

        /** Renders the authentication form (login/signup). */
        const renderAuthForm = () => {
            appContainer.innerHTML = `
                <div class="flex items-center justify-center min-h-screen w-full p-4">
                    <div class="bg-gray-800 p-8 rounded-2xl shadow-xl w-full max-w-sm border border-gray-700">
                        <h2 class="text-4xl font-extrabold text-center mb-6 text-indigo-400">Mindscribe</h2>
                        <div id="auth-form" class="space-y-4">
                            <input id="email-input" type="email" placeholder="Email" class="w-full p-3 rounded-lg bg-gray-700 text-white placeholder-gray-400 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <input id="password-input" type="password" placeholder="Password" class="w-full p-3 rounded-lg bg-gray-700 text-white placeholder-gray-400 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <button id="auth-button" class="w-full p-3 rounded-lg font-bold text-white bg-indigo-600 hover:bg-indigo-700 transition-colors duration-200 shadow-md">Login</button>
                            <button id="google-auth-button" class="w-full p-3 rounded-lg font-bold text-gray-300 border border-gray-600 hover:bg-gray-700 transition-colors duration-200">Sign In with Google</button>
                        </div>
                        <p id="auth-toggle" class="text-center mt-4 text-gray-400">
                            Don't have an account? <span class="text-indigo-400 cursor-pointer font-semibold hover:underline">Sign Up</span>
                        </p>
                        <div id="message-box" class="hidden"></div>
                    </div>
                </div>
            `;
            setupAuthEventListeners();
        };

        /** Renders the main dashboard for logged-in users. */
        const renderDashboard = () => {
            appContainer.innerHTML = `
                <div class="flex flex-grow min-h-screen">
                    <!-- Sidebar -->
                    <aside id="sidebar" class="w-80 min-h-screen p-6 bg-gray-800 shadow-xl flex flex-col border-r border-gray-700">
                        <h1 class="text-3xl font-extrabold mb-6 text-indigo-400">Mindscribe</h1>
                        
                        <!-- User Info -->
                        <div class="p-4 mb-6 rounded-xl bg-gray-700 flex flex-col items-center">
                            <span class="text-sm text-gray-400 font-medium">User ID:</span>
                            <span id="user-id-display" class="text-xs truncate text-white font-mono mt-1">${state.userId}</span>
                            <button id="logout-button" class="px-4 py-2 mt-3 rounded-lg text-sm font-semibold bg-red-600 hover:bg-red-700 transition-colors duration-200 text-white shadow-md w-full">Logout</button>
                        </div>
                        
                        <!-- Notebook Creation -->
                        <div class="mb-6">
                            <button id="new-notebook-button" class="w-full p-3 rounded-lg font-bold text-white bg-indigo-600 hover:bg-indigo-700 transition-colors duration-200 shadow-md">New Notebook</button>
                            <form id="new-notebook-form" class="mt-3 flex hidden">
                                <input id="new-notebook-input" type="text" placeholder="Notebook name" class="flex-grow p-3 rounded-l-lg bg-gray-700 text-white placeholder-gray-400 border border-gray-600 focus:outline-none">
                                <button type="submit" class="p-3 rounded-r-lg bg-indigo-600 hover:bg-indigo-700 text-white font-bold transition-colors">+</button>
                            </form>
                        </div>

                        <!-- Notebook List -->
                        <nav class="flex-grow overflow-y-auto pr-2 mb-6 space-y-2">
                            <h2 class="text-xl font-bold mb-3 text-white">Notebooks</h2>
                            <ul id="notebooks-list">
                                <!-- Notebook items will be rendered here -->
                            </ul>
                        </nav>
                        
                        <!-- Notes Actions -->
                        <div class="mt-auto">
                            <button id="new-note-button" class="w-full p-3 rounded-lg font-bold text-white bg-green-600 hover:bg-green-700 transition-colors duration-200 shadow-md">New Note</button>
                        </div>
                    </aside>

                    <!-- Main Content Panel -->
                    <main class="flex-grow p-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <!-- Notes List -->
                        <div class="lg:col-span-1 p-6 rounded-2xl bg-gray-800 shadow-lg border border-gray-700 flex flex-col">
                            <h2 class="text-2xl font-bold mb-4 text-white">Notes</h2>
                            <ul id="notes-list" class="flex-grow overflow-y-auto pr-2 space-y-2">
                                <!-- Note items will be rendered here -->
                            </ul>
                            <div id="no-notes-message" class="text-center text-gray-500 mt-4 hidden">
                                <p>No notes in this notebook. Create one!</p>
                            </div>
                        </div>

                        <!-- Note Editor and AI Assistant -->
                        <div class="lg:col-span-2 flex flex-col">
                            <div id="note-editor-panel" class="p-6 rounded-2xl bg-gray-800 shadow-lg border border-gray-700 flex-grow mb-6">
                                <!-- Editor content will be rendered here -->
                            </div>
                            <div id="ai-chat-panel" class="p-6 rounded-2xl bg-gray-800 shadow-lg border border-gray-700 flex-grow">
                                <!-- AI chat content will be rendered here -->
                            </div>
                        </div>
                    </main>
                </div>
            `;
            setupDashboardEventListeners();
            setupFirestoreListeners();
            renderNotebooks();
            renderNotes();
            renderNoteEditor();
            renderAIChat();
        };

        /** Renders the list of notebooks in the sidebar. */
        const renderNotebooks = () => {
            const notebooksList = document.getElementById('notebooks-list');
            if (!notebooksList) return;
            
            notebooksList.innerHTML = state.notebooks.map(notebook => `
                <li data-id="${notebook.id}" class="flex items-center justify-between p-3 rounded-lg cursor-pointer transition-colors duration-200 ${
                    state.selectedNotebookId === notebook.id ? 'bg-indigo-600 text-white shadow-lg' : 'hover:bg-gray-700'
                }">
                    <span class="font-medium">${notebook.name}</span>
                    <button data-id="${notebook.id}" class="delete-notebook-btn text-gray-400 hover:text-red-500 transition-colors duration-200 text-xl font-bold leading-none">
                        &times;
                    </button>
                </li>
            `).join('');
        };

        /** Renders the list of notes in the notes panel. */
        const renderNotes = () => {
            const notesList = document.getElementById('notes-list');
            const noNotesMessage = document.getElementById('no-notes-message');
            if (!notesList) return;

            const formatDate = (date) => {
                if (date && date.toDate) {
                    const options = { year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric' };
                    return date.toDate().toLocaleDateString('en-US', options);
                }
                return 'N/A';
            };

            if (state.notes.length === 0) {
                noNotesMessage.classList.remove('hidden');
                notesList.innerHTML = '';
            } else {
                noNotesMessage.classList.add('hidden');
                notesList.innerHTML = state.notes.map(note => `
                    <li data-id="${note.id}" class="p-4 rounded-lg cursor-pointer shadow-md transition-all duration-200 ${
                        state.selectedNoteId === note.id ? 'bg-indigo-600 text-white' : 'bg-gray-700 hover:bg-gray-600'
                    }">
                        <h3 class="font-semibold text-lg ${state.selectedNoteId === note.id ? '' : 'text-white'}">${note.title || 'Untitled Note'}</h3>
                        <p class="text-sm ${state.selectedNoteId === note.id ? 'text-gray-200' : 'text-gray-400'}">${note.updatedAt ? formatDate(note.updatedAt) : 'N/A'}</p>
                    </li>
                `).join('');
            }
        };

        /** Renders the note editor panel. */
        const renderNoteEditor = () => {
            const editorPanel = document.getElementById('note-editor-panel');
            if (!editorPanel) return;
            const selectedNote = state.notes.find(n => n.id === state.selectedNoteId);

            if (selectedNote) {
                const formatDate = (date) => {
                    if (date && date.toDate) {
                        const options = { year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric' };
                        return date.toDate().toLocaleDateString('en-US', options);
                    }
                    return 'Never';
                };
                const lastUpdated = selectedNote.updatedAt ? formatDate(selectedNote.updatedAt) : 'Never';

                editorPanel.innerHTML = `
                    <div class="flex flex-col h-full">
                        <div class="flex items-center justify-between mb-4">
                            <input id="note-title-input" type="text" value="${selectedNote.title}" placeholder="Note Title" class="text-3xl font-bold w-full bg-transparent outline-none text-white placeholder-gray-500">
                        </div>
                        <p class="text-sm text-gray-500 mb-4">Last Updated: ${lastUpdated}</p>
                        <textarea id="note-content-textarea" placeholder="Start writing..." class="flex-grow p-4 rounded-xl bg-gray-700 text-white resize-none outline-none focus:ring-2 focus:ring-indigo-500 w-full h-full">${selectedNote.content}</textarea>
                        <div class="flex gap-4 mt-4">
                            <button id="delete-note-button" class="flex-1 px-6 py-3 rounded-lg text-white bg-red-600 hover:bg-red-700 transition-colors duration-200 font-bold shadow-md">
                                Delete Note
                            </button>
                            <button id="export-note-button" class="flex-1 px-6 py-3 rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white font-bold transition-colors duration-200 shadow-md">
                                Export Markdown
                            </button>
                        </div>
                    </div>
                `;
                setupEditorEventListeners();
            } else {
                editorPanel.innerHTML = `
                    <div class="flex items-center justify-center h-full text-center text-gray-500">
                        <p class="text-xl font-medium">Select a note or create a new one.</p>
                    </div>
                `;
            }
        };

        /** Renders the AI chat panel. */
        const renderAIChat = () => {
            const chatPanel = document.getElementById('ai-chat-panel');
            if (!chatPanel) return;

            chatPanel.innerHTML = `
                <div class="flex flex-col h-full">
                    <h3 class="text-xl font-bold mb-4 text-white">AI Assistant</h3>
                    <div id="ai-response" class="flex-grow overflow-y-auto mb-4 p-4 rounded-xl bg-gray-700">
                        <p class="whitespace-pre-wrap text-gray-400">Ask a question or request a summary here...</p>
                    </div>
                    <div class="flex gap-4 mt-auto">
                        <input id="ai-prompt-input" type="text" placeholder="Ask AI a question..." class="flex-grow p-3 rounded-lg border border-gray-600 bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <button id="ai-send-button" class="px-6 py-3 rounded-lg font-bold text-white bg-indigo-600 hover:bg-indigo-700 transition-colors duration-200 shadow-md">Send</button>
                    </div>
                </div>
            `;
            setupAIChatEventListeners();
        };

        // --- Event Listener Setup ---

        /** Sets up event listeners for the authentication form. */
        const setupAuthEventListeners = () => {
            const authButton = document.getElementById('auth-button');
            const googleAuthButton = document.getElementById('google-auth-button');
            const authToggle = document.getElementById('auth-toggle');
            const emailInput = document.getElementById('email-input');
            const passwordInput = document.getElementById('password-input');
            let isLogin = true;

            if (authToggle) {
                authToggle.addEventListener('click', () => {
                    isLogin = !isLogin;
                    authButton.textContent = isLogin ? 'Login' : 'Sign Up';
                    authToggle.innerHTML = isLogin ? "Don't have an account? <span class='text-indigo-400 cursor-pointer font-semibold hover:underline'>Sign Up</span>" : "Already have an account? <span class='text-indigo-400 cursor-pointer font-semibold hover:underline'>Login</span>";
                });
            }

            if (authButton) {
                authButton.addEventListener('click', async () => {
                    try {
                        if (isLogin) {
                            await signInWithEmailAndPassword(auth, emailInput.value, passwordInput.value);
                        } else {
                            await createUserWithEmailAndPassword(auth, emailInput.value, passwordInput.value);
                        }
                    } catch (error) {
                        showMessage(error.message, true);
                    }
                });
            }

            if (googleAuthButton) {
                googleAuthButton.addEventListener('click', async () => {
                    const provider = new GoogleAuthProvider();
                    try {
                        await signInWithPopup(auth, provider);
                    } catch (error) {
                        showMessage(error.message, true);
                    }
                });
            }
        };

        /** Sets up event listeners for the dashboard UI. */
        const setupDashboardEventListeners = () => {
            // Logout
            document.getElementById('logout-button')?.addEventListener('click', () => {
                signOut(auth);
            });

            // New Notebook
            const newNotebookBtn = document.getElementById('new-notebook-button');
            const newNotebookForm = document.getElementById('new-notebook-form');
            if (newNotebookBtn && newNotebookForm) {
                newNotebookBtn.addEventListener('click', () => {
                    newNotebookForm.classList.toggle('hidden');
                });
                newNotebookForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const input = document.getElementById('new-notebook-input');
                    if (input.value.trim()) {
                        await createNotebook(input.value.trim());
                        input.value = '';
                        newNotebookForm.classList.add('hidden');
                    }
                });
            }

            // Notebook Selection & Deletion
            document.getElementById('notebooks-list')?.addEventListener('click', async (e) => {
                const targetLi = e.target.closest('li');
                if (targetLi) {
                    const notebookId = targetLi.dataset.id;
                    if (notebookId) {
                        state.selectedNotebookId = notebookId;
                        state.selectedNoteId = null; // Reset selected note when notebook changes
                        renderNotebooks();
                        setupNotesListener(notebookId);
                    }
                } else if (e.target.classList.contains('delete-notebook-btn')) {
                    e.stopPropagation();
                    const notebookId = e.target.dataset.id;
                    if (notebookId) {
                        await deleteNotebook(notebookId);
                    }
                }
            });

            // New Note
            document.getElementById('new-note-button')?.addEventListener('click', () => {
                if (state.selectedNotebookId) {
                    createNote(state.selectedNotebookId);
                } else {
                    showMessage("Please select or create a notebook first.", true);
                }
            });

            // Note Selection
            document.getElementById('notes-list')?.addEventListener('click', (e) => {
                const listItem = e.target.closest('li');
                if (listItem) {
                    const noteId = listItem.dataset.id;
                    if (noteId) {
                        state.selectedNoteId = noteId;
                        renderNotes();
                        renderNoteEditor();
                    }
                }
            });
        };

        /** Sets up event listeners for the note editor. */
        const setupEditorEventListeners = () => {
            const titleInput = document.getElementById('note-title-input');
            const contentTextarea = document.getElementById('note-content-textarea');
            const deleteBtn = document.getElementById('delete-note-button');
            const exportBtn = document.getElementById('export-note-button');

            // Debounced auto-save
            let debounceTimer;
            const handleUpdate = () => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    if (state.selectedNoteId) {
                        updateNote(state.selectedNoteId, {
                            title: titleInput.value,
                            content: contentTextarea.value,
                        });
                    }
                }, 500);
            };

            if (titleInput) {
                titleInput.addEventListener('input', handleUpdate);
            }
            if (contentTextarea) {
                contentTextarea.addEventListener('input', handleUpdate);
            }

            if (deleteBtn) {
                deleteBtn.addEventListener('click', () => {
                    deleteNote(state.selectedNoteId);
                });
            }

            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                    const markdownContent = `# ${titleInput.value}\n\n${contentTextarea.value}`;
                    const tempTextArea = document.createElement('textarea');
                    tempTextArea.value = markdownContent;
                    document.body.appendChild(tempTextArea);
                    tempTextArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempTextArea);
                    showMessage("Note copied to clipboard!");
                });
            }
        };

        /** Sets up event listeners for the AI chat panel. */
        const setupAIChatEventListeners = () => {
            const aiPromptInput = document.getElementById('ai-prompt-input');
            const aiSendButton = document.getElementById('ai-send-button');
            const aiResponsePanel = document.getElementById('ai-response');

            const handleGeminiCall = async () => {
                const prompt = aiPromptInput.value;
                if (!prompt) return;

                aiResponsePanel.innerHTML = `<p class="whitespace-pre-wrap text-gray-500">Thinking...</p>`;
                if (aiSendButton) aiSendButton.disabled = true;

                const selectedNote = state.notes.find(n => n.id === state.selectedNoteId);
                const promptWithContext = selectedNote
                    ? `Based on the following note content: "${selectedNote.content}", ${prompt}`
                    : prompt;

                const chatHistory = [{ role: "user", parts: [{ text: promptWithContext }] }];
                const payload = { contents: chatHistory };
                const apiKey = "AIzaSyAFbJJ4Q16Uh-CVC36kao3XTDOUUtc6VGo"
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                let resultText = "Failed to get a response from the AI. Please try again.";
                let retries = 0;
                const maxRetries = 3;
                const initialDelay = 1000;

                while (retries < maxRetries) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const result = await response.json();
                        if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                            resultText = result.candidates[0].content.parts[0].text;
                            break; // Success, exit the retry loop
                        } else {
                            throw new Error("Unexpected response structure from the API.");
                        }
                    } catch (error) {
                        console.error(`Attempt ${retries + 1} failed:`, error);
                        retries++;
                        if (retries < maxRetries) {
                            const delay = initialDelay * Math.pow(2, retries - 1);
                            await new Promise(res => setTimeout(res, delay));
                        }
                    }
                }
                
                aiResponsePanel.innerHTML = `<p class="whitespace-pre-wrap text-white">${resultText}</p>`;
                if (aiSendButton) aiSendButton.disabled = false;
            };

            if (aiSendButton) {
                aiSendButton.addEventListener('click', handleGeminiCall);
            }
            if (aiPromptInput) {
                aiPromptInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        handleGeminiCall();
                    }
                });
            }
        };

        // --- Firebase Data Operations ---

        /** Creates a new notebook in Firestore. */
        const createNotebook = async (name) => {
            if (!db || !state.userId) return;
            try {
                const notebookRef = collection(db, 'artifacts', appId, 'users', state.userId, 'notebooks');
                const newDoc = await addDoc(notebookRef, { name, createdAt: new Date() });
                state.selectedNotebookId = newDoc.id;
            } catch (e) {
                console.error("Error creating notebook: ", e);
                showMessage("Failed to create notebook.", true);
            }
        };

        /** Deletes a notebook and all its associated notes. */
        const deleteNotebook = async (id) => {
            if (!db || !state.userId) return;
            try {
                const notesRef = collection(db, 'artifacts', appId, 'users', state.userId, 'notes');
                const q = query(notesRef, where('notebookId', '==', id));
                const querySnapshot = await getDocs(q);
                const deletePromises = querySnapshot.docs.map(noteDoc => deleteDoc(doc(notesRef, noteDoc.id)));
                await Promise.all(deletePromises);
                await deleteDoc(doc(db, 'artifacts', appId, 'users', state.userId, 'notebooks', id));
                
                // Select the first remaining notebook, or null if none exist
                const remainingNotebooks = state.notebooks.filter(n => n.id !== id);
                state.selectedNotebookId = remainingNotebooks.length > 0 ? remainingNotebooks[0].id : null;
                renderNotebooks();
                if (state.selectedNotebookId) {
                    setupNotesListener(state.selectedNotebookId);
                } else {
                    state.notes = [];
                    state.selectedNoteId = null;
                    renderNotes();
                    renderNoteEditor();
                }
            } catch (e) {
                console.error("Error deleting notebook: ", e);
                showMessage("Failed to delete notebook.", true);
            }
        };

        /** Creates a new note in Firestore. */
        const createNote = async (notebookId) => {
            if (!db || !state.userId) return;
            try {
                const notesRef = collection(db, 'artifacts', appId, 'users', state.userId, 'notes');
                const newDoc = await addDoc(notesRef, {
                    title: 'New Note',
                    content: '',
                    notebookId,
                    createdAt: new Date(),
                    updatedAt: new Date()
                });
                state.selectedNoteId = newDoc.id;
            } catch (e) {
                console.error("Error creating note: ", e);
                showMessage("Failed to create note.", true);
            }
        };

        /** Updates an existing note in Firestore. */
        const updateNote = async (id, updatedFields) => {
            if (!db || !state.userId) return;
            try {
                const noteRef = doc(db, 'artifacts', appId, 'users', state.userId, 'notes', id);
                await updateDoc(noteRef, { ...updatedFields, updatedAt: new Date() });
            } catch (e) {
                console.error("Error updating note: ", e);
                showMessage("Failed to update note.", true);
            }
        };

        /** Deletes a note from Firestore. */
        const deleteNote = async (id) => {
            if (!db || !state.userId) return;
            try {
                await deleteDoc(doc(db, 'artifacts', appId, 'users', state.userId, 'notes', id));
                const remainingNotes = state.notes.filter(n => n.id !== id);
                state.selectedNoteId = remainingNotes.length > 0 ? remainingNotes[0].id : null;
                renderNotes();
                renderNoteEditor();
            } catch (e) {
                console.error("Error deleting note: ", e);
                showMessage("Failed to delete note.", true);
            }
        };

        // --- Firebase Listeners ---

        /** Sets up real-time listener for notebooks. */
        const setupNotebooksListener = () => {
            if (!state.userId) return;
            const notebooksCol = collection(db, 'artifacts', appId, 'users', state.userId, 'notebooks');
            onSnapshot(notebooksCol, (snapshot) => {
                state.notebooks = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                if (state.notebooks.length > 0 && !state.selectedNotebookId) {
                    state.selectedNotebookId = state.notebooks[0].id;
                    setupNotesListener(state.selectedNotebookId);
                } else if (state.notebooks.length === 0) {
                    state.selectedNotebookId = null;
                    state.notes = [];
                    state.selectedNoteId = null;
                    renderNotes();
                    renderNoteEditor();
                }
                renderNotebooks();
            }, (error) => {
                console.error("Error fetching notebooks:", error);
            });
        };

        /** Sets up a real-time listener for notes of a specific notebook. */
        const setupNotesListener = (notebookId) => {
            if (!state.userId || !notebookId) return;

            // Unsubscribe from the previous listener if it exists
            if (noteUnsubscribe) {
                noteUnsubscribe();
            }

            const notesCol = collection(db, 'artifacts', appId, 'users', state.userId, 'notes');
            const q = query(notesCol, where('notebookId', '==', notebookId));

            noteUnsubscribe = onSnapshot(q, (snapshot) => {
                state.notes = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                state.notes.sort((a, b) => b.updatedAt.toDate().getTime() - a.updatedAt.toDate().getTime());
                
                // If the selected note is not in the new list, select the first one
                if (state.notes.length > 0 && (!state.selectedNoteId || !state.notes.find(n => n.id === state.selectedNoteId))) {
                    state.selectedNoteId = state.notes[0].id;
                } else if (state.notes.length === 0) {
                    state.selectedNoteId = null;
                }
                renderNotes();
                renderNoteEditor();
            }, (error) => {
                console.error("Error fetching notes:", error);
            });
        };
        
        /** Sets up real-time listeners for notebooks and notes. */
        const setupFirestoreListeners = () => {
            if (!state.userId) return;
            setupNotebooksListener();
        };

        // --- Main Application Flow ---

        /** Initializes the application based on the authentication state. */
        const initializeAppFlow = async () => {
            // Listen for changes in the user's authentication state
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    state.user = user;
                    state.userId = user.uid;
                    renderDashboard();
                } else {
                    state.user = null;
                    state.userId = null;
                    renderAuthForm();
                }
            });

            // Attempt to sign in with the custom token if available, otherwise sign in anonymously
            if (initialAuthToken) {
                try {
                    await signInWithCustomToken(auth, initialAuthToken);
                } catch (error) {
                    console.error("Error signing in with custom token:", error);
                    // Fall back to anonymous sign-in if the custom token fails
                    signInAnonymously(auth);
                }
            } else {
                 signInAnonymously(auth);
            }
        };

        window.onload = initializeAppFlow;
    </script>
</body>
</html>
