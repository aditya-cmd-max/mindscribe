<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mindscribe</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-100 transition-colors duration-300">

    <!-- Main Container for the entire application -->
    <!-- Initial content is a simple loading message to prevent a blank screen -->
    <div id="app" class="min-h-screen flex items-center justify-center">
        <div class="text-center">
            <h2 class="text-2xl font-semibold animate-pulse">Loading Mindscribe...</h2>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyB7F1uRRiGdw489c_18aJeodbxrzsdFb5c",
            authDomain: "exonova-cd89c.firebaseapp.com",
            databaseURL: "https://exonova-cd89c-default-rtdb.firebaseio.com",
            projectId: "exonova-cd89c",
            storageBucket: "exonova-cd89c.firebasestorage.app",
            messagingSenderId: "465326262278",
            appId: "1:465326262278:web:1b7f8f62e1f46c5ca7db87",
            measurementId: "G-GGG45V0PEF"
        };
        
        // Use the global variables provided by the Canvas environment if available
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- Application State and Initialization ---
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Global state object
        const state = {
            user: null,
            userId: null,
            isAuthReady: false,
            notebooks: [],
            notes: [],
            selectedNotebookId: null,
            selectedNoteId: null,
            isDarkMode: false,
            message: ''
        };

        // DOM elements
        const appContainer = document.getElementById('app');

        // Helper function to update the message display
        const showMessage = (message, isError = false) => {
            state.message = message;
            const messageEl = document.getElementById('message-box');
            if (messageEl) {
                messageEl.textContent = message;
                messageEl.className = `p-3 rounded-xl shadow-lg mt-4 ${isError ? 'bg-red-100 text-red-700 dark:bg-red-800 dark:text-red-100' : 'bg-green-100 text-green-700 dark:bg-green-800 dark:text-green-100'}`;
                messageEl.classList.remove('hidden');
                setTimeout(() => {
                    messageEl.classList.add('hidden');
                }, 5000);
            }
        };

        // --- User Interface Rendering Functions ---

        /** Renders the authentication form (login/signup). */
        const renderAuthForm = () => {
            appContainer.innerHTML = `
                <div class="flex items-center justify-center min-h-screen w-full">
                    <div class="bg-white dark:bg-gray-800 p-8 rounded-xl shadow-lg w-full max-w-sm">
                        <h2 class="text-3xl font-bold text-center mb-6 text-gray-800 dark:text-gray-100">Mindscribe</h2>
                        <div id="auth-form" class="space-y-4">
                            <input id="email-input" type="email" placeholder="Email" class="w-full p-3 rounded-md border border-gray-300 dark:bg-gray-700 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <input id="password-input" type="password" placeholder="Password" class="w-full p-3 rounded-md border border-gray-300 dark:bg-gray-700 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <button id="auth-button" class="w-full p-3 rounded-md font-semibold text-white bg-indigo-600 hover:bg-indigo-700 transition-colors">Login</button>
                            <button id="google-auth-button" class="w-full p-3 rounded-md font-semibold text-gray-800 dark:text-gray-100 border border-gray-300 dark:border-gray-600 transition-colors">Sign In with Google</button>
                        </div>
                        <p id="auth-toggle" class="text-center mt-4 text-gray-800 dark:text-gray-100">
                            Don't have an account? <span class="text-indigo-600 cursor-pointer font-medium">Sign Up</span>
                        </p>
                        <div id="message-box" class="hidden"></div>
                    </div>
                </div>
            `;
            setupAuthEventListeners();
        };

        /** Renders the main dashboard for logged-in users. */
        const renderDashboard = () => {
            appContainer.innerHTML = `
                <div class="flex flex-grow min-h-screen">
                    <!-- Sidebar -->
                    <aside id="sidebar" class="w-80 min-h-screen p-4 bg-white dark:bg-gray-800 shadow-lg flex flex-col">
                        <h1 class="text-2xl font-bold mb-4">Mindscribe</h1>
                        
                        <!-- User Info -->
                        <div class="p-3 mb-4 rounded-xl bg-gray-100 dark:bg-gray-700 flex items-center justify-between">
                            <div class="flex flex-col">
                                <span class="text-sm text-gray-500">User ID:</span>
                                <span id="user-id-display" class="text-xs truncate text-gray-800 dark:text-gray-100">${state.userId}</span>
                            </div>
                            <button id="logout-button" class="px-3 py-1 rounded-md text-sm font-medium bg-indigo-600 hover:bg-indigo-700 transition-colors text-white">Logout</button>
                        </div>
                        
                        <!-- Notebook Creation -->
                        <div class="mb-4">
                            <button id="new-notebook-button" class="w-full p-2 rounded-md font-semibold text-white bg-indigo-600 hover:bg-indigo-700 transition-colors">New Notebook</button>
                            <form id="new-notebook-form" class="mt-2 flex hidden">
                                <input id="new-notebook-input" type="text" placeholder="Notebook name" class="flex-grow p-2 rounded-l-md border border-gray-300 dark:bg-gray-700 dark:border-gray-600 focus:outline-none">
                                <button type="submit" class="p-2 rounded-r-md bg-indigo-600 hover:bg-indigo-700 text-white">+</button>
                            </form>
                        </div>

                        <!-- Notebook List -->
                        <nav class="flex-grow overflow-y-auto pr-2 mb-4">
                            <h2 class="text-lg font-semibold mb-2">Notebooks</h2>
                            <ul id="notebooks-list">
                                <!-- Notebook items will be rendered here -->
                            </ul>
                        </nav>
                        
                        <!-- Notes Actions -->
                        <div class="mb-4">
                            <button id="new-note-button" class="w-full p-2 rounded-md font-semibold text-white bg-indigo-600 hover:bg-indigo-700 transition-colors">New Note</button>
                        </div>
                        
                        <!-- Dark Mode Toggle -->
                        <div class="mt-auto flex justify-between items-center">
                            <span>Dark Mode</span>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input id="dark-mode-toggle" type="checkbox" class="sr-only peer" ${state.isDarkMode ? 'checked' : ''}>
                                <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
                            </label>
                        </div>
                    </aside>

                    <!-- Main Content Panel -->
                    <main class="flex-grow p-4 grid grid-cols-1 lg:grid-cols-3 gap-4">
                        <!-- Notes List -->
                        <div class="lg:col-span-1 p-4 rounded-xl bg-white dark:bg-gray-800 overflow-y-auto">
                            <h2 class="text-2xl font-bold mb-4">Notes</h2>
                            <ul id="notes-list">
                                <!-- Note items will be rendered here -->
                            </ul>
                        </div>

                        <!-- Note Editor and AI Assistant -->
                        <div class="lg:col-span-2 flex flex-col">
                            <div id="note-editor-panel" class="p-4 rounded-xl bg-white dark:bg-gray-800 flex-grow mb-4">
                                <!-- Editor content will be rendered here -->
                            </div>
                            <div id="ai-chat-panel" class="p-4 rounded-xl bg-white dark:bg-gray-800 flex-grow">
                                <!-- AI chat content will be rendered here -->
                            </div>
                        </div>
                    </main>
                </div>
            `;
            setupDashboardEventListeners();
            renderNotebooks();
            renderNotes();
            renderNoteEditor();
            renderAIChat();
        };

        /** Renders the list of notebooks in the sidebar. */
        const renderNotebooks = () => {
            const notebooksList = document.getElementById('notebooks-list');
            if (!notebooksList) return;
            
            notebooksList.innerHTML = state.notebooks.map(notebook => `
                <li data-id="${notebook.id}" class="flex items-center justify-between p-2 rounded-md cursor-pointer mb-1 ${
                    state.selectedNotebookId === notebook.id ? 'bg-indigo-600 text-white' : 'hover:bg-gray-200 dark:hover:bg-gray-700'
                }">
                    <span>${notebook.name}</span>
                    <button data-id="${notebook.id}" class="delete-notebook-btn ${state.selectedNotebookId === notebook.id ? 'text-white' : 'text-gray-500 hover:text-red-500'}">
                        &times;
                    </button>
                </li>
            `).join('');
        };

        /** Renders the list of notes in the notes panel. */
        const renderNotes = () => {
            const notesList = document.getElementById('notes-list');
            if (!notesList) return;

            const formatDate = (date) => {
                const options = { year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric' };
                return date.toLocaleDateString('en-US', options);
            };

            notesList.innerHTML = state.notes.map(note => `
                <li data-id="${note.id}" class="p-3 rounded-md cursor-pointer mb-2 transition-colors ${
                    state.selectedNoteId === note.id ? 'bg-indigo-600 text-white' : 'hover:bg-gray-200 dark:hover:bg-gray-700'
                }">
                    <h3 class="font-semibold ${state.selectedNoteId === note.id ? '' : 'text-gray-800 dark:text-gray-100'}">${note.title || 'Untitled Note'}</h3>
                    <p class="text-sm ${state.selectedNoteId === note.id ? 'text-gray-200' : 'text-gray-500'}">${note.updatedAt ? formatDate(note.updatedAt.toDate()) : 'N/A'}</p>
                </li>
            `).join('');
        };

        /** Renders the note editor panel. */
        const renderNoteEditor = () => {
            const editorPanel = document.getElementById('note-editor-panel');
            if (!editorPanel) return;
            const selectedNote = state.notes.find(n => n.id === state.selectedNoteId);

            if (selectedNote) {
                const formatDate = (date) => {
                    const options = { year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric' };
                    return date.toLocaleDateString('en-US', options);
                };
                const lastUpdated = selectedNote.updatedAt ? formatDate(selectedNote.updatedAt.toDate()) : 'Never';

                editorPanel.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <input id="note-title-input" type="text" value="${selectedNote.title}" placeholder="Note Title" class="text-2xl font-bold w-full bg-transparent outline-none text-gray-800 dark:text-gray-100">
                    </div>
                    <p class="text-sm text-gray-500 mb-4">Last Updated: ${lastUpdated}</p>
                    <textarea id="note-content-textarea" placeholder="Start writing..." class="flex-grow p-2 rounded-lg bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-100 resize-none outline-none focus:ring-2 focus:ring-indigo-500 w-full h-96">${selectedNote.content}</textarea>
                    <div class="flex gap-2 mt-4">
                        <button id="delete-note-button" class="px-4 py-2 rounded-lg text-white bg-red-600 hover:bg-red-700 transition-colors font-semibold">
                            Delete Note
                        </button>
                        <button id="export-note-button" class="px-4 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white font-semibold transition-colors">
                            Export Markdown
                        </button>
                    </div>
                `;
                setupEditorEventListeners();
            } else {
                editorPanel.innerHTML = `
                    <div class="flex items-center justify-center h-full text-center text-gray-800 dark:text-gray-100">
                        <p class="text-xl font-medium">Select a note from the sidebar or create a new one.</p>
                    </div>
                `;
            }
        };

        /** Renders the AI chat panel. */
        const renderAIChat = () => {
            const chatPanel = document.getElementById('ai-chat-panel');
            if (!chatPanel) return;

            chatPanel.innerHTML = `
                <div class="flex flex-col h-full">
                    <h3 class="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-100">AI Assistant</h3>
                    <div id="ai-response" class="flex-grow overflow-y-auto mb-4 p-2 rounded-lg bg-gray-100 dark:bg-gray-900">
                        <p class="whitespace-pre-wrap text-gray-800 dark:text-gray-100">Ask a question or request a summary here...</p>
                    </div>
                    <div class="flex gap-2 mt-auto">
                        <input id="ai-prompt-input" type="text" placeholder="Ask AI a question..." class="flex-grow p-2 rounded-lg border border-gray-300 dark:bg-gray-700 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <button id="ai-send-button" class="px-4 py-2 rounded-lg font-semibold text-white bg-indigo-600 hover:bg-indigo-700 transition-colors">Send</button>
                    </div>
                </div>
            `;
            setupAIChatEventListeners();
        };

        // --- Event Listener Setup ---

        /** Sets up event listeners for the authentication form. */
        const setupAuthEventListeners = () => {
            const authButton = document.getElementById('auth-button');
            const googleAuthButton = document.getElementById('google-auth-button');
            const authToggle = document.getElementById('auth-toggle');
            const emailInput = document.getElementById('email-input');
            const passwordInput = document.getElementById('password-input');
            let isLogin = true;

            authToggle.addEventListener('click', () => {
                isLogin = !isLogin;
                authButton.textContent = isLogin ? 'Login' : 'Sign Up';
                authToggle.innerHTML = isLogin ? "Don't have an account? <span class='text-indigo-600 cursor-pointer font-medium'>Sign Up</span>" : "Already have an account? <span class='text-indigo-600 cursor-pointer font-medium'>Login</span>";
            });

            authButton.addEventListener('click', async () => {
                try {
                    if (isLogin) {
                        await signInWithEmailAndPassword(auth, emailInput.value, passwordInput.value);
                    } else {
                        await createUserWithEmailAndPassword(auth, emailInput.value, passwordInput.value);
                    }
                } catch (error) {
                    showMessage(error.message, true);
                }
            });

            googleAuthButton.addEventListener('click', async () => {
                const provider = new GoogleAuthProvider();
                try {
                    await signInWithPopup(auth, provider);
                } catch (error) {
                    showMessage(error.message, true);
                }
            });
        };

        /** Sets up event listeners for the dashboard UI. */
        const setupDashboardEventListeners = () => {
            // Logout
            document.getElementById('logout-button').addEventListener('click', () => {
                signOut(auth);
            });

            // Dark Mode
            document.getElementById('dark-mode-toggle').addEventListener('change', (e) => {
                state.isDarkMode = e.target.checked;
                document.documentElement.classList.toggle('dark', state.isDarkMode);
            });

            // New Notebook
            const newNotebookBtn = document.getElementById('new-notebook-button');
            const newNotebookForm = document.getElementById('new-notebook-form');
            newNotebookBtn.addEventListener('click', () => {
                newNotebookForm.classList.toggle('hidden');
            });

            newNotebookForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const input = document.getElementById('new-notebook-input');
                if (input.value.trim()) {
                    await createNotebook(input.value.trim());
                    input.value = '';
                    newNotebookForm.classList.add('hidden');
                }
            });

            // Notebook Selection & Deletion
            document.getElementById('notebooks-list').addEventListener('click', async (e) => {
                if (e.target.tagName === 'LI') {
                    const notebookId = e.target.dataset.id;
                    if (notebookId) {
                        state.selectedNotebookId = notebookId;
                        state.selectedNoteId = null; // Reset selected note when notebook changes
                        renderNotes();
                        renderNotebooks();
                        renderNoteEditor();
                    }
                } else if (e.target.classList.contains('delete-notebook-btn')) {
                    e.stopPropagation();
                    const notebookId = e.target.dataset.id;
                    if (notebookId) {
                        await deleteNotebook(notebookId);
                    }
                }
            });

            // New Note
            document.getElementById('new-note-button').addEventListener('click', () => {
                if (state.selectedNotebookId) {
                    createNote(state.selectedNotebookId);
                } else {
                    showMessage("Please select or create a notebook first.", true);
                }
            });

            // Note Selection
            document.getElementById('notes-list').addEventListener('click', (e) => {
                const listItem = e.target.closest('li');
                if (listItem) {
                    const noteId = listItem.dataset.id;
                    if (noteId) {
                        state.selectedNoteId = noteId;
                        renderNotes();
                        renderNoteEditor();
                    }
                }
            });
        };

        /** Sets up event listeners for the note editor. */
        const setupEditorEventListeners = () => {
            const titleInput = document.getElementById('note-title-input');
            const contentTextarea = document.getElementById('note-content-textarea');
            const deleteBtn = document.getElementById('delete-note-button');
            const exportBtn = document.getElementById('export-note-button');

            // Debounced auto-save
            let debounceTimer;
            const handleUpdate = () => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    if (state.selectedNoteId) {
                        updateNote(state.selectedNoteId, {
                            title: titleInput.value,
                            content: contentTextarea.value,
                        });
                    }
                }, 500);
            };

            if (titleInput && contentTextarea) {
                titleInput.addEventListener('input', handleUpdate);
                contentTextarea.addEventListener('input', handleUpdate);
            }

            if (deleteBtn) {
                deleteBtn.addEventListener('click', () => {
                    deleteNote(state.selectedNoteId);
                });
            }

            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                    const markdownContent = `# ${titleInput.value}\n\n${contentTextarea.value}`;
                    document.execCommand('copy');
                    showMessage("Note copied to clipboard!");
                });
            }
        };

        /** Sets up event listeners for the AI chat panel. */
        const setupAIChatEventListeners = () => {
            const aiPromptInput = document.getElementById('ai-prompt-input');
            const aiSendButton = document.getElementById('ai-send-button');
            const aiResponsePanel = document.getElementById('ai-response');

            const handleGeminiCall = async () => {
                const prompt = aiPromptInput.value;
                if (!prompt) return;

                aiResponsePanel.innerHTML = `<p class="whitespace-pre-wrap text-gray-500">Thinking...</p>`;
                aiSendButton.disabled = true;

                const selectedNote = state.notes.find(n => n.id === state.selectedNoteId);
                const promptWithContext = selectedNote
                    ? `Based on the following note content: "${selectedNote.content}", ${prompt}`
                    : prompt;

                const chatHistory = [{ role: "user", parts: [{ text: promptWithContext }] }];
                const payload = { contents: chatHistory };
                const apiKey = "AIzaSyAFbJJ4Q16Uh-CVC36kao3XTDOUUtc6VGo"
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                let resultText = "Failed to get a response from the AI. Please try again.";
                let retries = 0;
                const maxRetries = 3;
                const initialDelay = 1000;

                while (retries < maxRetries) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const result = await response.json();
                        if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                            resultText = result.candidates[0].content.parts[0].text;
                            break; // Success, exit the retry loop
                        } else {
                            throw new Error("Unexpected response structure from the API.");
                        }
                    } catch (error) {
                        console.error(`Attempt ${retries + 1} failed:`, error);
                        retries++;
                        if (retries < maxRetries) {
                            const delay = initialDelay * Math.pow(2, retries - 1);
                            await new Promise(res => setTimeout(res, delay));
                        }
                    }
                }
                
                aiResponsePanel.innerHTML = `<p class="whitespace-pre-wrap">${resultText}</p>`;
                aiSendButton.disabled = false;
            };

            aiSendButton.addEventListener('click', handleGeminiCall);
            aiPromptInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    handleGeminiCall();
                }
            });
        };

        // --- Firebase Data Operations ---

        /** Creates a new notebook in Firestore. */
        const createNotebook = async (name) => {
            if (!db || !state.userId) return;
            try {
                const notebookRef = collection(db, 'artifacts', appId, 'users', state.userId, 'notebooks');
                const newDoc = await addDoc(notebookRef, { name, createdAt: new Date() });
                state.selectedNotebookId = newDoc.id;
            } catch (e) {
                console.error("Error creating notebook: ", e);
                showMessage("Failed to create notebook.", true);
            }
        };

        /** Deletes a notebook and all its associated notes. */
        const deleteNotebook = async (id) => {
            if (!db || !state.userId) return;
            try {
                const notesRef = collection(db, 'artifacts', appId, 'users', state.userId, 'notes');
                const q = query(notesRef, where('notebookId', '==', id));
                const querySnapshot = await getDocs(q);
                const deletePromises = querySnapshot.docs.map(noteDoc => deleteDoc(doc(notesRef, noteDoc.id)));
                await Promise.all(deletePromises);
                await deleteDoc(doc(db, 'artifacts', appId, 'users', state.userId, 'notebooks', id));
                state.selectedNotebookId = state.notebooks[0]?.id || null;
                renderNotebooks();
            } catch (e) {
                console.error("Error deleting notebook: ", e);
                showMessage("Failed to delete notebook.", true);
            }
        };

        /** Creates a new note in Firestore. */
        const createNote = async (notebookId) => {
            if (!db || !state.userId) return;
            try {
                const notesRef = collection(db, 'artifacts', appId, 'users', state.userId, 'notes');
                const newDoc = await addDoc(notesRef, {
                    title: 'New Note',
                    content: '',
                    notebookId,
                    createdAt: new Date(),
                    updatedAt: new Date()
                });
                state.selectedNoteId = newDoc.id;
                renderNotes();
                renderNoteEditor();
            } catch (e) {
                console.error("Error creating note: ", e);
                showMessage("Failed to create note.", true);
            }
        };

        /** Updates an existing note in Firestore. */
        const updateNote = async (id, updatedFields) => {
            if (!db || !state.userId) return;
            try {
                const noteRef = doc(db, 'artifacts', appId, 'users', state.userId, 'notes', id);
                await updateDoc(noteRef, { ...updatedFields, updatedAt: new Date() });
            } catch (e) {
                console.error("Error updating note: ", e);
                showMessage("Failed to update note.", true);
            }
        };

        /** Deletes a note from Firestore. */
        const deleteNote = async (id) => {
            if (!db || !state.userId) return;
            try {
                await deleteDoc(doc(db, 'artifacts', appId, 'users', state.userId, 'notes', id));
                state.selectedNoteId = state.notes.length > 1 ? state.notes.find(n => n.id !== id)?.id : null;
                renderNotes();
                renderNoteEditor();
            } catch (e) {
                console.error("Error deleting note: ", e);
                showMessage("Failed to delete note.", true);
            }
        };

        // --- Firebase Listeners ---

        /** Sets up real-time listeners for notebooks and notes. */
        const setupFirestoreListeners = () => {
            if (!state.userId) return;

            // Notebooks listener
            const notebooksCol = collection(db, 'artifacts', appId, 'users', state.userId, 'notebooks');
            onSnapshot(notebooksCol, (snapshot) => {
                state.notebooks = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                if (state.notebooks.length > 0 && !state.selectedNotebookId) {
                    state.selectedNotebookId = state.notebooks[0].id;
                }
                renderNotebooks();
            }, (error) => {
                console.error("Error fetching notebooks:", error);
            });

            // Notes listener
            const notesCol = collection(db, 'artifacts', appId, 'users', state.userId, 'notes');
            onSnapshot(notesCol, (snapshot) => {
                state.notes = snapshot.docs
                    .map(doc => ({ id: doc.id, ...doc.data() }))
                    .filter(note => note.notebookId === state.selectedNotebookId);
                state.notes.sort((a, b) => b.updatedAt.toDate().getTime() - a.updatedAt.toDate().getTime());
                if (state.notes.length > 0 && !state.selectedNoteId) {
                    state.selectedNoteId = state.notes[0].id;
                } else if (state.notes.length === 0) {
                    state.selectedNoteId = null;
                }
                renderNotes();
                renderNoteEditor();
            }, (error) => {
                console.error("Error fetching notes:", error);
            });
        };

        // --- Main Application Flow ---

        /** Initializes the application based on the authentication state. */
        const initializeAppFlow = () => {
            // Use a flag to ensure the UI is only rendered once the auth state is known
            let initialAuthCheck = false;

            // Listen for changes in the user's authentication state
            onAuthStateChanged(auth, (user) => {
                if (!initialAuthCheck) {
                    initialAuthCheck = true;
                    if (user) {
                        state.user = user;
                        state.userId = user.uid;
                        renderDashboard();
                        setupFirestoreListeners();
                    } else {
                        state.user = null;
                        state.userId = null;
                        renderAuthForm();
                    }
                    state.isAuthReady = true;
                }
            });

            // Use an async function for the initial token sign-in to fix the SyntaxError
            const initialSignIn = async () => {
                if (initialAuthToken) {
                    try {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } catch (error) {
                        console.error("Error signing in with custom token:", error);
                        // If custom token fails, fall back to anonymous sign-in
                        signInAnonymously(auth);
                    }
                } else {
                     signInAnonymously(auth);
                }
            };

            initialSignIn();
        };

        window.onload = initializeAppFlow;
    </script>
</body>
</html>
